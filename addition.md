
## 수정할 사항들

## _byteswap_uint64()

* zip은 압축된 데이터의 원본 크기를 제공하지 않는다.
* 타 머신에서 복원된 데이터의 버퍼를 확보하기 위해서는 원본의 크기가 필요하다.
* 리틀엔디안으로 크기를 써 넣기 위해서 위 함수가 필요했다.
* vc9, vc10에서는 확인했지만, vc7, vc8에서 기본 지원하는지 확인하지 못 했다.
* gcc에서 어느 버전부터 지원하는지 확인하지 못 했다.

## cstdint 와 stdint.h

* tr1에는 위 헤더에 기본 타입의 크기가 명확히 표시되어 있다.
* tr1전의 std에서 확신할 수 있는 데이터 크기는 unsigned char이다.
* 4Gbytes이상을 표시하기 위해 8바이트의 데이터 타입이 필요했다.
* vc는 unsigned __int64를 지원하므로, 이것을 사용했다.
* gcc는 확신할 수 없지만 stdint.h 를 사용했다.

## allocator

* 일반적으로 c 라이브러리는 사용자 버퍼를 요구하지만, 이 라이브러리는 std 컨테이너을 리턴하게 구현했다.
* 라이브러리에서 자주 resize를 호출하기때문에 오버헤드가 발생할 수 있다.
* allocator를 구현하여 최소화할 수 있지만, 몇가지 어려운 점이 있다.
* 요구 버퍼는 완전히 가변적이다. 가변 메모리풀로 구현해야 한다.
* allocator는 쓰레드 세이프해야 한다. 그러다보니, 락객체를 구현해야 한다.
* 락객체는 OS에 훨씬 종속적이어서, 이것을 std만으로 구현하겠다는 의도를 벗어난다.
* 우선은 boost의 allocator를 샘플로 제공하고자 한다.

## 다른 플래폼

* std만으로 구현하여, std를 지원할 경우 사용 가능하게 하려한다.
* 내부 암호화 코드에서 cpu 성향이 결정된다. 이미 빌드된 openssl을 사용할 경우 문제가될 수 있다.
* openssl로 밖에 제공할 수 없는 일부 암호화를 다른 코드로 대체할 것이다. (라이브러리를 전부 소스로 지원되게 할 것이다.)
* 적어도 gcc에서 빌드 및 실행테스트를 해야 한다.
* 위 사항이 만족되면, 라이브러리 빌드를 cmake로 변경할 것이다.

## EMPTY 타입

* interface.h 가 있지만, 그다지 도움을 주지는 않는다.(없어도 사용가능하므로, 코드수 줄이는게 더 낫다.)
* 오히려 "암호화모듈들의 메소드가 어떠한 방식으로 동작해야 한다"는 제한사항에 더 가깝다.
* 이 룰을 지키려다보니 빌드만을 위해 필요한 타입이 생겼다.
* 빌드만을 위한 빈 타입이라는 건데, 딱히 더 멋진 방법이 떠 오르지 않는다.